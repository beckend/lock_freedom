var searchIndex = {};
searchIndex["lockfree"] = {"doc":"","items":[[0,"prelude","lockfree","Provides convenient re-exports.",null,null],[4,"Ordering","lockfree::prelude","Atomic memory orderings",null,null],[13,"Relaxed","","No ordering constraints, only atomic operations.",0,null],[13,"Release","","When coupled with a store, all previous writes become visible to the other threads that perform a load with [`Acquire`] ordering on the same value.",0,null],[13,"Acquire","","When coupled with a load, all subsequent loads will see data written before a store with [`Release`] ordering on the same value in other threads.",0,null],[13,"AcqRel","","Has the effects of both [`Acquire`] and [`Release`] together.",0,null],[13,"SeqCst","","Like `AcqRel` with the additional guarantee that all threads see all sequentially consistent operations in the same order.",0,null],[0,"hazard","lockfree","Hazard pointer API. Please, note that this API is not implemented in the \"traditional\" way hazard pointers are implemented. This is because this implemention aims to be lock-free.",null,null],[4,"Ordering","lockfree::hazard","Atomic memory orderings",null,null],[13,"Relaxed","","No ordering constraints, only atomic operations.",0,null],[13,"Release","","When coupled with a store, all previous writes become visible to the other threads that perform a load with [`Acquire`] ordering on the same value.",0,null],[13,"Acquire","","When coupled with a load, all subsequent loads will see data written before a store with [`Release`] ordering on the same value in other threads.",0,null],[13,"AcqRel","","Has the effects of both [`Acquire`] and [`Release`] together.",0,null],[13,"SeqCst","","Like `AcqRel` with the additional guarantee that all threads see all sequentially consistent operations in the same order.",0,null],[3,"HazardPtr","","A hazard atomic pointer. It keeps a destructor with itself. The destruction and loading of this pointer uses the hazard API of this module. Because it (possibly later) calls the destructor on drop, be very careful. In general, if the pointer is consumed, you may want to fill the hazard pointer with `std::ptr::null_mut()` and check it on your drop.",null,null],[5,"later_drop","","Adds the given pointer and drop function to the local deletion queue. If there is no critical code executing, the local queue items are deleted. The function is unsafe because pointers must be correctly dropped such as no \"use after free\" or \"double free\" happens.",null,null],[5,"try_delete_local","","Tries to delete the local queue items.",null,{"o":{"n":"result"}}],[5,"critical","","Executes the given function as critical code. No deletions of new queues will start during this execution.",null,{"i":[{"n":"f"}],"o":{"n":"t"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new pointer from the given dropper and initial ptr. The dropper is run at the `HazardPtr<T>`'s `Drop`. Also, it may be used for dropping intermediate pointers explicitly.",1,null],[11,"load","","Loads the pointer atomically as critical code.",1,{"i":[{"n":"self"},{"n":"ordering"},{"n":"f"}],"o":{"n":"a"}}],[11,"store","","Stores the pointer atomically.",1,null],[11,"swap","","Swaps the pointer atomically as critical code.",1,null],[11,"compare_and_swap","","Compares the given `curr` argument with the actual stored pointer, and, if the comparison succeeds, swaps it with the given `new` pointer. The whole operation is atomic and is run as critical code.",1,null],[11,"compare_exchange","","Compares the given `curr` argument with the actual stored pointer, and, if the comparison succeeds, swaps it with the given `new` pointer. The whole operation is atomic and is run as critical code. This method accepts two orderings: one for success and one for failure.",1,null],[11,"compare_exchange_weak","","Same as `compare_exchange`, but with weaker semanthics (it might perform better).",1,null],[11,"apply_dropper","","Applies the dropper to some pointer. This function is unsafe because incorrectly applying the destructor may result in \"use after free\" or \"double free\".",1,null],[11,"drop","","",1,{"i":[{"n":"self"}]}],[0,"queue","lockfree","Provides a queue with strict FIFO semanthics in single and multithread environments.",null,null],[3,"Queue","lockfree::queue","A strict FIFO semanthics queue. This queue uses the hazard API. It can be used as multi-producer and multi-consumer channel.",null,null],[3,"Iter","","An iterator based on `pop` operation of the `Queue`.",null,null],[11,"new","","Creates a new empty queue.",2,{"o":{"n":"self"}}],[11,"push","","Pushes a value into the back of the queue. This operation is also wait-free.",2,{"i":[{"n":"self"},{"n":"t"}]}],[11,"pop","","Takes a value from the front of the queue, if it is avaible.",2,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"extend","","Extends the queue from a given iterable.",2,{"i":[{"n":"self"},{"n":"i"}]}],[11,"iter","","Creates an iterator over `T`s, based on `pop` operation of the queue.",2,{"i":[{"n":"self"}],"o":{"n":"iter"}}],[11,"drop","","",2,{"i":[{"n":"self"}]}],[11,"from_iter","","",2,{"i":[{"n":"i"}],"o":{"n":"self"}}],[11,"next","","",3,{"i":[{"n":"self"}],"o":{"n":"option"}}],[0,"loose_queue","lockfree","Provides a queue without FIFO garantees on multithread environments, but still concurrent and lock-free. Single thread environments still have FIFO garanteees. This queue does not use the hazard API.",null,null],[3,"LooseQueue","lockfree::loose_queue","A lock-free concurrent queue, but without FIFO garantees on multithreaded environments. Single thread environments still have FIFO garantees. The queue is based on subqueues which threads try to take, modify and then publish. If necessary, subqueues are appended.",null,null],[3,"Inspector","","An iterator which inspects a subqueue.",null,null],[3,"Drainer","","A drainer over the queue.",null,null],[11,"new","","Creates a new empty queue.",4,{"o":{"n":"self"}}],[11,"push","","Pushes a value in the back of the queue.",4,{"i":[{"n":"self"},{"n":"t"}]}],[11,"pop","","Pops a value from the front of the queue.",4,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"append","","Appends some other queue to the end of this one.",4,{"i":[{"n":"self"},{"n":"self"}]}],[11,"extend","","Extends the queue from an iterator.",4,{"i":[{"n":"self"},{"n":"i"}]}],[11,"inspect","","Creates an inspector on the current subqueue. The inspector takes the subqueue for itself and restores it on drop.",4,{"i":[{"n":"self"}],"o":{"n":"inspector"}}],[11,"drain","","Creates a drainer on the current subqueue. The drainer takes the subqueue for itself and restores what is left of it on drop.",4,{"i":[{"n":"self"}],"o":{"n":"drainer"}}],[11,"drop","","",4,{"i":[{"n":"self"}]}],[11,"from_iter","","",4,{"i":[{"n":"i"}],"o":{"n":"self"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"next","","",5,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"drop","","",5,{"i":[{"n":"self"}]}],[11,"fmt","","",5,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"next","","",6,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"drop","","",6,{"i":[{"n":"self"}]}],[11,"fmt","","",6,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","lockfree::hazard","",0,{"i":[{"n":"self"}],"o":{"n":"ordering"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}]],"paths":[[4,"Ordering"],[3,"HazardPtr"],[3,"Queue"],[3,"Iter"],[3,"LooseQueue"],[3,"Inspector"],[3,"Drainer"]]};
initSearch(searchIndex);
