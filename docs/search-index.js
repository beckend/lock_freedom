var searchIndex = {};
searchIndex["lockfree"] = {"doc":"","items":[[0,"prelude","lockfree","Provides convenient re-exports.",null,null],[0,"hazard","","Hazard pointer API. Please, note that this API is not implemented in the \"traditional\" way hazard pointers are implemented. This is because this implemention aims to be lock-free.",null,null],[4,"Ordering","lockfree::hazard","Atomic memory orderings",null,null],[13,"Relaxed","","No ordering constraints, only atomic operations.",0,null],[13,"Release","","When coupled with a store, all previous writes become visible to the other threads that perform a load with [`Acquire`] ordering on the same value.",0,null],[13,"Acquire","","When coupled with a load, all subsequent loads will see data written before a store with [`Release`] ordering on the same value in other threads.",0,null],[13,"AcqRel","","Has the effects of both [`Acquire`] and [`Release`] together.",0,null],[13,"SeqCst","","Like `AcqRel` with the additional guarantee that all threads see all sequentially consistent operations in the same order.",0,null],[3,"HazardPtr","","A hazard atomic pointer. The loading of this pointer uses the hazard API of this module. In general, one should only apply a `later_drop` on a loaded pointer after one has replaced it.",null,null],[5,"later_drop","","Adds the given pointer and drop function to the local deletion queue. If there is no critical code executing, the local queue items are deleted. The function is unsafe because pointers must be correctly dropped such as no \"use after free\" or \"double free\" happens.",null,null],[5,"try_delete_local","","Tries to delete the local queue items.",null,{"o":{"n":"result"}}],[5,"critical","","Executes the given function as critical code. No deletions of new queues will start during this execution.",null,{"i":[{"n":"f"}],"o":{"n":"t"}}],[11,"fmt","","",1,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new pointer from the given and initial ptr.",1,null],[11,"load","","Loads the pointer atomically as critical code.",1,{"i":[{"n":"self"},{"n":"ordering"},{"n":"f"}],"o":{"n":"a"}}],[11,"store","","Stores the pointer atomically.",1,null],[11,"swap","","Swaps the pointer atomically as critical code.",1,null],[11,"compare_and_swap","","Compares the given `curr` argument with the actual stored pointer, and, if the comparison succeeds, swaps it with the given `new` pointer. The whole operation is atomic and is run as critical code.",1,null],[11,"compare_exchange","","Compares the given `curr` argument with the actual stored pointer, and, if the comparison succeeds, swaps it with the given `new` pointer. The whole operation is atomic and is run as critical code. This method accepts two orderings: one for success and one for failure.",1,null],[11,"compare_exchange_weak","","Same as `compare_exchange`, but with weaker semanthics (it might perform better).",1,null],[0,"queue","lockfree","A lock-free queue.",null,null],[3,"Queue","lockfree::queue","A lock-free queue. FIFO semanthics are fully respected. It can be used as multi-producer and multi-consumer channel.",null,null],[3,"Iter","","An iterator based on `pop` operation of the `Queue`.",null,null],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new empty queue.",2,{"o":{"n":"self"}}],[11,"push","","Pushes a value into the back of the queue. This operation is also wait-free.",2,{"i":[{"n":"self"},{"n":"t"}]}],[11,"pop","","Takes a value from the front of the queue, if it is avaible.",2,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"extend","","Extends the queue from a given iterable.",2,{"i":[{"n":"self"},{"n":"i"}]}],[11,"iter","","Creates an iterator over `T`s, based on `pop` operation of the queue.",2,{"i":[{"n":"self"}],"o":{"n":"iter"}}],[11,"default","","",2,{"o":{"n":"self"}}],[11,"drop","","",2,{"i":[{"n":"self"}]}],[11,"from_iter","","",2,{"i":[{"n":"i"}],"o":{"n":"self"}}],[11,"next","","",3,{"i":[{"n":"self"}],"o":{"n":"option"}}],[0,"stack","lockfree","A lock-free stack.",null,null],[3,"Stack","lockfree::stack","A lock-free stack. LIFO/FILO semanthics are fully respected.",null,null],[3,"Iter","","An iterator based on `pop` operation of the `Stack`.",null,null],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new empty stack.",4,{"o":{"n":"self"}}],[11,"push","","Pushes a new value onto the top of the stack.",4,{"i":[{"n":"self"},{"n":"t"}]}],[11,"pop","","Pops a single element from the top of the stack.",4,{"i":[{"n":"self"}],"o":{"n":"option"}}],[11,"extend","","Extends the stack from a given iterable. All values are pushed.",4,{"i":[{"n":"self"},{"n":"i"}]}],[11,"iter","","Creates an iterator over `T`s, based on `pop` operation of the stack.",4,{"i":[{"n":"self"}],"o":{"n":"iter"}}],[11,"default","","",4,{"o":{"n":"self"}}],[11,"drop","","",4,{"i":[{"n":"self"}]}],[11,"from_iter","","",4,{"i":[{"n":"i"}],"o":{"n":"self"}}],[11,"next","","",5,{"i":[{"n":"self"}],"o":{"n":"option"}}],[0,"darc","lockfree","Provides a doubly atomic reference counter.",null,null],[4,"Ordering","lockfree::darc","Atomic memory orderings",null,null],[13,"Relaxed","","No ordering constraints, only atomic operations.",0,null],[13,"Release","","When coupled with a store, all previous writes become visible to the other threads that perform a load with [`Acquire`] ordering on the same value.",0,null],[13,"Acquire","","When coupled with a load, all subsequent loads will see data written before a store with [`Release`] ordering on the same value in other threads.",0,null],[13,"AcqRel","","Has the effects of both [`Acquire`] and [`Release`] together.",0,null],[13,"SeqCst","","Like `AcqRel` with the additional guarantee that all threads see all sequentially consistent operations in the same order.",0,null],[3,"Darc","","Darc: Doubly atomic reference counter. `Darc` is an atomic pointer which stores `Arc`s.",null,null],[11,"fmt","","",6,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new `Darc` from the given `Arc`.",6,{"i":[{"n":"arc"}],"o":{"n":"self"}}],[11,"load","","Loads the `Darc` into an `Arc`.",6,{"i":[{"n":"self"},{"n":"ordering"}],"o":{"n":"arc"}}],[11,"store","","Stores an `Arc` inconditionally. This is the same as swaping with unused return.",6,{"i":[{"n":"self"},{"n":"arc"},{"n":"ordering"}]}],[11,"swap","","Swaps the inner `Arc` with the argument `new` inconditionally.",6,{"i":[{"n":"self"},{"n":"arc"},{"n":"ordering"}],"o":{"n":"arc"}}],[11,"compare_and_swap","","Compares the inner `Arc` with `curr`, and if they are the same pointer, the inner `Arc` is swapped with `new`. To test the result, use `Arc::ptr_eq(&curr, &ret)`.",6,{"i":[{"n":"self"},{"n":"arc"},{"n":"arc"},{"n":"ordering"}],"o":{"n":"arc"}}],[11,"compare_exchange","","Same as `compare_and_swap` but accepts two `Ordering`s: one for failure and one for success. Also, it returns a `Result` instead.",6,{"i":[{"n":"self"},{"n":"arc"},{"n":"arc"},{"n":"ordering"},{"n":"ordering"}],"o":{"g":["arc","arc"],"n":"result"}}],[11,"compare_exchange_weak","","Same as `compare_exchange` but with weaker semanthics.",6,{"i":[{"n":"self"},{"n":"arc"},{"n":"arc"},{"n":"ordering"},{"n":"ordering"}],"o":{"g":["arc","arc"],"n":"result"}}],[11,"drop","","",6,{"i":[{"n":"self"}]}],[11,"from","","",6,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"ordering"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"g":["error"],"n":"result"}}]],"paths":[[4,"Ordering"],[3,"HazardPtr"],[3,"Queue"],[3,"Iter"],[3,"Stack"],[3,"Iter"],[3,"Darc"]]};
initSearch(searchIndex);
